# Массив в JavaScript: `slice` против `splice`

В JavaScript использование `slice` вместо `splice` (и наоборот) является 
распространённой ошибкой среди новичков и даже профессионалов. Эти два метода, 
хотя и очень **похожи по названию**, выполняют два **абсолютно разных** действия. 
На практике ошибки можно избежать, если подобрать API, который будет 
анализировать правильность записи функции.

У `slice` для массивов (Раздел [15.4.4.10][1] Спецификации ECMAScript версии 5.1) 
много общего со `slice` для строк. Согласно спецификации, `slice` принимает два 
аргумента, *начальный* и *конечный*. Он возвращает **новый массив**, содержащий 
элементы начиная с указанного начального индекса вплоть до элемента, 
расположенного сразу перед конечным индексом. Понять что делает `slice` несложно:

    'abc'.slice(1,2)           // "b"
    [14, 3, 77].slice(1, 2)    //  [3]

Важным качеством метода `slice` является то, что он **не изменяет** массив, 
который использует. Следующий фрагмент кода иллюстрирует его поведение. Как 
видите, в массиве x элементы сохранены, а в `y` помещены полученные после 
обработки массива x методом `slice`. 

    var x = [14, 3, 77];
    var y = x.slice(1, 2);
    console.log(x);          // [14, 3, 77]
    console.log(y);          // [3]

Хотя `splice` (Раздел [15.4.4.12][2]) также принимает два аргумента (как 
минимум), его предназначение абсолютно иное:

    [14, 3, 77].slice(1, 2)     //  [3]
    [14, 3, 77].splice(1, 2)    //  [3, 77]

В добавок к этому, `splice` **модифицирует** массив, для которого он вызван. В 
этом впрочем нет ничего удивительного, ведь имя `splice` это и подразумевает 
(*«splice» — «наращивать, сращивать», прим. переводчика*).

    var x = [14, 3, 77]
    var y = x.splice(1, 2)
    console.log(x)           // [14]
    console.log(y)           // [3, 77]

Создавая свой программный модуль, важно выбрать API, который минимизирует 
путаницу со *slice* и *splice*. В идеале, пользователь вашего модуля должен 
иметь возможность определиться какой из них ему нужен не читая документацию. 
Какие условные обозначения стоит выбрать?

Для меня привычным (благодаря моему прошлому увлечению Qt) является условное 
обозначение с помощью формы глагола: *глагол в форме настоящего определённого 
времени* для обозначения действия, которое может модифицировать объект 
применения, и *причастие прошедшего времени* для возвращения новой версии без 
модификации объекта. Если возможно, предоставьте пару этих методов. Следующий 
пример наглядно демонстрирует суть концепции:

    var p = new Point(100, 75);
    p.translate(25, 25);
    console.log(p);       // { x: 125, y: 100 }
 
    var q = new Point(200, 100);
    var s = q.translated(10, 50);
    console.log(q);       // { x: 200, y: 100 }
    console.log(s);       // { x: 210, y: 150 }

Обратите внимание на разницу между `translate()`, который служит для перемещения 
точки (в двухмерной системе декартовых координат) и `translated()`, который 
служит лишь для создания преобразованной версии. Объект-точка *p* изменился, 
потому что для него был использован `translate`. В то же время, объект *q* 
остаётся неизменным, так как `translated()` его **не модифицирует**, а лишь 
возвращает **новый вариант** в виде нового объекта *s*.

Если использовать такие условные обозначения последовательно по всему приложению, 
вероятность путаницы существенно снизится. И в один прекрасный день ваши 
пользователи смогут с уверенностью заявить: «Ну вот теперь всё понятно».

[1]: http://es5.github.io/#x15.4.4.10
[2]: http://es5.github.io/#x15.4.4.12